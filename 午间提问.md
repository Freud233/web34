## HTML/CSS
1. 简述一下你对HTML语义化的理解？
> 1. HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；
> 2. 即使在没有样式CSS 的情况下也能以一种文档格式显示，并且是容易阅读的；
> 3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；
> 4. 使阅读源代码的人更容易将网站分块，便于阅读、维护和理解；
2. CSS中优雅降级和渐进增强有什么区别？
> 渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。
> 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
#### display: none;与visibility: hidden;的区别
他们的作用都是让元素不可见
区别：
display：none会让元素完全从 dom 树中消失，渲染的时候不占据任何空间。
visibility：hidden不会让元素从渲染树 dom 中消失，而且还是会占据一定的空间，只是内容不可见而已。
## JS组成
1. javascript语法
2. DOM 页面文档对象模型
3. BOM 浏览器对象模型
### js三种书写方式
1. 行内 `<div onclick="alert('nihao')"></div>`
2. 内嵌 `<script> alert('大家好')</script>`
3. 外联 `<script src="index.js">`
### 数据类型
1. 简单数据类型 Number, String, Boolean, Undefined, Null
2. 复杂数据类型 Object(Array,Date,RegExp,Function)

#### 递增 递减 区别
1. ++num, 先自加后返回 `var num = 2; alert(++num + 10); // 13`
2. num++, 先返回值后自加 `var num = 2; alert(num++ + 10); // 12`
#### "==" 和 "===" 的区别？
> 前者会自动转换类型,而后者不会。
> 前者比较的是值，后者比较的是值和类型。
## 数组 
+ concat()	连接两个或更多的数组，并返回结果。
+ join()	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
+ pop()	删除并返回数组的最后一个元素
+ push()	向数组的末尾添加一个或更多元素，并返回新的长度。
+ reverse()	颠倒数组中元素的顺序。
+ shift()	删除并返回数组的第一个元素
+ slice()	从某个已有的数组返回选定的元素
+ sort()	对数组的元素进行排序
+ splice()	删除元素，并向数组添加新元素。
+ toSource()	返回该对象的源代码。
+ toString()	把数组转换为字符串，并返回结果。
+ toLocaleString()	把数组转换为本地数组，并返回结果。
+ unshift()	向数组的开头添加一个或更多元素，并返回新的长度。
+ valueOf()	返回数组对象的原始
#### continue, break, return区别
+ `continue // 跳过本次循环, 继续下次循环`
+ `break // 跳出循环体, 循环结束`
+ `return // 跳出循环, 返回return后的值或者代码`

### 函数的声明方式
1. 自定义函数
```js
function fn() {...}
fn(); // 调用
```
2. 函数表达式
```js
var fn = function() {...}
fn();
```
### 预解析
+ 预解析:在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提 前声明或者定义。
### 对象的三种创建方式
1. 字面量创建
```js
var obj = {
  name: '蔡徐坤',
  age: 18,
  gender: '男',
  skill() {
    alert('我是练习时长两年半的个人练习生')
  }
}
```                               
2. 利用 new Object 创建对象
```js
var obj = new Obecjt()
obj.name = '切格瓦拉';
obj.age = 18;
obj.gender = '男';
obj.skill = function() { alert('打工是不可能打工的') }
```
3. 利用构造函数创建对象
```js
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  this.skill = function() {
    console.log(`我是${this.name}, 我会打工`);
  }
}
var person = new Person('吴亦凡', 18, '男');
```
new 关键字的作用
1. 在构造函数代码开始执行之前，创建一个空对象; 
2. 修改this的指向，把this指向创建出来的空对象; 
3. 执行函数的代码
4. 在函数完成之后，返回this---即创建出来的对象
### 遍历对象
#### for...in
```js
for (var key in obj) { // key为对象的属性名 
  console.log(obj[key])
}
```

### 获取元素
1. 根据ID获取
document.getElementById(id)
2. 根据标签名获取元素
document.getElementsByTagName('标签名')
3. 根据类名获取元素
document.getElementsByClassName
4. `document.querySelcetor() // id, 类, 标签名`  
5. `document.querySelcetorAll() // id, 类, 标签名` 

### 事件三要素
1. 事件源 ：要触发的对象  （一般是名词，事件发起者，比如开关按钮）

2. 事件：怎么触发这个事情  （一般是动词，触发事件，比如点击）

3. 事件处理程序:发生了什么事情 （处理结果，比如灯亮了）



### 改变元素内容
**innerText和innerHTML的区别**

- 获取内容时的区别：

​	innerText会去除空格和换行，而innerHTML会保留空格和换行	

- 设置内容时的区别：

​	innerText不会识别html，而innerText不会识别

#### call、apply、bind三者的异同

- 共同点 : 都可以改变this指向
- 不同点:
  - call 和 apply  会调用函数, 并且改变函数内部this指向.
  - call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递
  - bind  不会调用函数, 可以改变函数内部this指向.


- 应用场景
  1. call 经常做继承. 
  2. apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值
  3. bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 

### 什么是闭包
闭包（closure）一个作用域可以访问另外一个函数内部的局部变量。

#### 什么是递归
> 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数
> 递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。
#### 数组去重
```js
function unique4(arr) {
    var newArr = []
    for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i])===-1) {
            newArr.push(arr[i])
        }
    }
    return newArr
}
console.log(unique4([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```
```js
function unique7(arr) {
    var newArr = []
    array.forEach(item => {
        return newArr.includes(item) ? '' : newArr.push(item)
    });
    return newArr
}
console.log(unique7([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```
```js
function unique6(arr) {
    var newArr = []
    newArr = arr.filter(function (item) {
        return newArr.includes(item) ? '' : newArr.push(item)
    })
    return newArr
}
console.log(unique6([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```
#### let和const
##### let
1. let不存在变量提升
2. let声明的变量存在块级作用域
3. let不允许在同一作用域重复声明同一个变量
4. 暂时性死区: 在代码块内, 使用let声明变量之前, 该变量不可以使用
##### const
1. const声明的常量不能改变, 意味着const一旦声明常量，就必须同时初始化。不能先声明，后初始化，这样会报错
2. const声明的常量也只在块级作用域内有效
3. 与let一样，必须先声明，后使用 
4. 与let一样，在同一作用域，const不能重复声明同一常量
### 说一说箭头函数
1. 箭头函数语法 `() => {}`
2. 箭头函数相当于匿名函数，不能作为构造函数，不能使用new
```js
var B = ()=>{
  value:1;
}
var b = new B();//Uncaught TypeError: B is not a constructor

```
3. 不绑定this, 在严格模式下函数调用为undefined
4. 箭头函数会捕获其所在上下文的this值，作为自己的this值。即箭头函数的作用域会继承自外围的作用域。

### 常用的函数定义方式

1. 方式1 函数声明方式 function 关键字 (命名函数)

   ```js
   function fn(){}
   ```

2. 方式2 函数表达式(匿名函数)

   ```js
   var fn = function(){}
   ```

### 函数的调用

```js
/* 1. 普通函数 */
function fn() {
	console.log('人生的巅峰');
}
 fn(); 
/* 2. 对象的方法 */
var o = {
  sayHi: function() {
  	console.log('人生的巅峰');
  }
}
o.sayHi();
/* 3. 构造函数*/
function Star() {};
new Star();
/* 4. 绑定事件函数*/
 btn.onclick = function() {};   // 点击了按钮就可以调用这个函数
/* 5. 定时器函数*/
setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次
/* 6. 立即执行函数(自调用函数)*/
(function() {
	console.log('人生的巅峰');
})();
```

### 对象的三种创建方式

1. 字面量方式

   ```js
   var obj = {};
   ```

2. new关键字

   ```js
   var obj = new Object();
   ```

3. 构造函数方式

   ```js
   function Person(name,age){
     this.name = name;
     this.age = age;
   }
   var obj = new Person('zs',12);
   ```

#### 轮播图无缝滚动的思路简述
1. 在第一张克隆一个最后一张的副本
2. 当切换到最后一张的时候, 点击下一张时, 利用js设置css样式瞬间切换到真正的第一张(最后一张的副本), 因为执行过程太快肉眼看不清楚, 看起来就无缝了
#### 数组去重
```js
function unique4(arr) {
    var newArr = []
    for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i])===-1) {
            newArr.push(arr[i])
        }
    }
    return newArr
}
console.log(unique4([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```
```js
function unique7(arr) {
    var newArr = []
    arr.forEach(item => {
      newArr.includes(item) ? '' : newArr.push(item)
    });
    return newArr
}
console.log(unique7([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```
```js
[...new Set([1,2,3,1,2,4,6,7,8,9,7])]
```
#### 请指出document.onload和document.ready两个事件的区别。
页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。
#### TAB栏切换
+ 略
#### continue, break, return区别
+ `continue // 跳过本次循环, 继续下次循环`
+ `break // 跳出循环体, 不再执行循环(结束当前的循环体)`
+ `return // 停止函数, 返回return后的值或者代码`
#### 正则表达式 
正则表达式: 一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
+ 灵活性、逻辑性和功能性非常的强
+ 简单的方式达到字符串的匹配, 减少代码量
+ 对于刚接触人员晦涩难懂
#### 面向对象和面向过程的优缺点
+ 面向过程
>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
缺点：没有面向对象易维护、易复用、易扩展
+ 面向对象
>优点：耦合度比较低、易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性, 
缺点：性能比面向过程低

### 对象

对象是由属性和方法组成的：是一个无需键值对的集合,指的是一个具体的事物

- 属性：事物的特征，在对象中用属性来表示（常用名词）
- 方法：事物的行为，在对象中用方法来表示（常用动词）
### 类

- 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象

### 严格模式的优点
ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。

1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。

2.消除代码运行的一些不安全之处，保证代码运行的安全。

3.提高编译器效率，增加运行速度。

4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名

### 构造函数实例和原型对象三角关系

```js
1. 构造函数的prototype属性指向了构造函数原型对象
2. 实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象
3. 构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数
```
### 说一说你常用的ES6语法
1. let / const `{let a = 1;} console.log(a) // a is not defined`
2. 箭头函数 `() => {}`
3. 模板字符串 
```js 
let a = 1;
let str = `a的值是${a}`;
```
4. 结构赋值 
```js
let [a, b, c] = [1, 2, 3];
// a 为 1 , b 为 2, c 为 3
```
5. 默认参数
> 之前我们不能直接为函数指定默认参数，因此很多时候为了保证传入的参数具备一个默认值
```js
function add(x, y) {
    var x = x || 20;
    var y = y || 30;
    return x + y;
}

console.log(add()); // 50

function add(x = 20, y = 30) {
    return x + y;
}

console.log(add()); // 50
```
6. 拓展运算符
> 将数组方法或者对象进行展开
```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 10, 20, 30];
// arr2 [1, 2, 3, 10, 20, 30];
```
7. 对象字面量简写
```js
//当属性与值的变量同名时。
const name = 'Jane';
const age = 20

// es6
const person = {
  name,
  age,
  getName() { // 只要不使用箭头函数，this就还是我们熟悉的this
    return this.name
  }
}

// es5
var person = {
  name: name,
  age: age,
  getName: function getName() {
    return this.name;
  }
};
```
---
8. Promise (先眼熟, 以后再了解)
> Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
---
### GET和POST的区别
1. GET在浏览器回退时是无害的，而POST会再次提交请求。

2. GET产生的URL地址可以收藏为书签，而POST不可以。

3. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。

4. GET请求只能进行url编码(application/x-www-form-urlencoded)，而POST(application/x-www-form-urlencoded 或 multipart/form-data)支持多种编码方式。

5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

6. GET请求在URL中传送的参数是有长度限制的(2KB)，而POST没有(限制它的是服务器的处理能力，与存储大小)。

7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

9. GET参数通过URL传递，POST放在Request body中。
#### 为什么JS是单线程模式(了解)
> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成这门语言的核心特征，将来也不会改变。

>注：所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。

+ 为什么会有同步和异步(了解)

  因为JavaScript的单线程，因此同个时间只能处理同个任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务，但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等着，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验

  因此，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务，因此，任务就可以分为同步任务和异步任务
#### 异步和同步的区别
+ 同步是阻塞模式，异步是非阻塞模式(node.js)
+ 同步指下一个程序的执行需要等到上一个程序执行完毕，也就是得出结果后下一个才能执行，

+ 异步指的是上一个程序指向后，下一个程序不用等到上一个程序出结果就能执行，等上一个出结果了调用回调函数处理结果就好。

#### 什么是AJAX
+ AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
+ 使用Ajax技术不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验

#### 实现AJAX的基本步骤
1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象.
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
3. 设置响应HTTP请求状态变化的函数.
4. 发送HTTP请求.
5. 获取异步调用返回的数据.
6. 使用JavaScript和DOM实现局部刷新.

#### 冒泡排序的思路
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
![冒泡排序](http://evernote1.oss-cn-shanghai.aliyuncs.com/2019-06-27-1609bbf94e918e1a.gif)
#### jQuery ajax基本参数(前五必记)
```js
$.ajax({
  type: '', // 规定请求的类型（GET 或 POST）
  url: '', // 规定发送请求的 URL
  data: '', // 规定要发送到服务器的数据
  dataType: '', // 预期的服务器响应的数据类型
  success(result) {} // 当请求成功时运行的函数

  async: '', // 布尔值，表示请求是否异步处理。默认是 true
  timeout: 1000, // 设置本地的请求超时时间（以毫秒计）
  beforeSend() {} // 发送请求前运行的函数
  error(error) {} // 请求失败时调用此函数
  complete() {} // 当请求完成之后调用这个函数，无论成功或失败
  ...
})
```

#### 什么是跨域
> **浏览器**同源策略是指协议 域名 端口三者相同, 如果三者任一不同就产生了跨域

![跨域](http://evernote1.oss-cn-shanghai.aliyuncs.com/2019-06-27-183346.jpg)


>使用ajax可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是**浏览器**出于对安全方面的考虑，不允许跨域调用其他页面的对象,这是一个用于隔离潜在恶意文件的重要安全机制

#### 模板引擎的好处
1. 简化了html书写, 提高开发效率高
2. 代码逻辑性更强（比如可以用循环和条件分支），对数据的展现更具有控制力
3. 分离数据与展现，更易维护和易扩展

#### jsonp的原理
> 利用了`<script src=""></script>`标签具有天然跨域的特性, 由服务器返回一个预先定义好的js函数的调用, 并将服务器数据以该函数参数的形式传递过来, 它只能以GET方式请求

#### 服务端渲染和客户端渲染的利弊
![](http://ww4.sinaimg.cn/large/006tNc79gy1g4gg99rujmj316o0gcjuf.jpg)
#### sessionStorage和localstroage与cookie之间有什么关联
+ 三者共同点：都是保存在浏览器端，且同源的

区别:
1. cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存

2. 存储大小限制也不同，cookie数据不能超过4k，sessionStorage和localStorage 但比cookie大得多，可以达到5M

3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面(即数据不共享)；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的( 即数据共享 )。

#### js中new到底做了什么
1. 创建一个新对象

2. 将构造函数的作用域赋给新对象, this指向了这个新对象 

3. 执行构造函数中的代码, 为这个新对象添加属性. 

4. 返回新对象

#### 什么是事件委托及其优点
> 事件委托就是利用事件冒泡机制指定一个事件处理程序，来管理某一类型的所有事件。即：利用冒泡的原理，把事件加到父级上，触发执行效果
1. 内存占用少： 因为每个事件处理函数都是对象，都会占用内存
2. DOM访问次数少： 提高性能,加快页面的交互就绪时间，因为不管什么时候，只要是访问DOM树中的一个元素，浏览器都会搜索整个DOM树，从中查找匹配的元素。
3. 动态绑定事件： 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适

#### 条件判断几种为false的情况
1. undefined
2. null
3. 0, -0, 0.0
4. NaN
5. false
6. `''`

### node.js搭一个简单服务器的步骤?
```js
//   fs    path    http
// 1. 先导入 Node 中提供的核心模块  http
const http = require('http')

// 2. 创建服务器
const server = http.createServer()

// 3. 为这个server服务器，通过  on  方法，绑定一个 事件
//     $('#btn').on('click', function(){})         $('div').on('mouseover', function(){})

// 问大家：这个 request 事件什么时候触发？  每当服务器接收到一个客户端的请求，就会立即触发这个 request 事件
// 注意： 我们在自己写服务器的时候，要时刻记着 请求 - 处理 - 响应 这个通信模型
// 在 服务器的 回调函数参数列表中， 有两个参数，其中，第一个参数，是 Request， 第二个参数是 Response
server.on('request', function (req, res) {
  console.log('ok')
  // 设置返回数据的格式
  // res.setHeader('Content-Type', 'text/html;charset=utf-8')
  res.writeHeader(200, {'Content-Type': 'text/html;charset=utf-8'}) 
  // 大家注意：每当请求处理完毕，必须 显示调用一下  response 对象的 end 方法，来结束这次响应，否则，客户端拿不到数据；在 调用 res.end 方法的时候，可以传递要返回给客户端的数据；
  res.end('hello world.')
})

// 4. 启动服务器
// listen 方法的第一个参数： 端口号
// 第二个参数，是IP地址，可选，P地址，可选，如果不填写，则默认监听 127.0.0.1
// 最后，还有一个回调函数，表示，当服务器正常启动之后，调用一下这个函数
//  http://127.0.0.1:3000
server.listen(3000, function () {
  console.log('通知大家，服务器已经启动了！') 
})
```
### node.js的三大模块系统?
#### 核心模块
1. 由Node官方提供好的模块叫做核心模块, 例如fs, http, path等;
2. 使用 `const fs = require('fs')`  
#### 第三方模块 
1. 非官方提供的模块叫第三方模块, 例如less, sass, jQuery等; 
2. 使用  
+ 下载`npm install less`
+ 导入 `require('less')`
+ 根据官方文档使用
#### 用户自定义模块
1. 程序员自己写的模块
2. 使用, 导入`require('路径')`
### 深拷贝和浅拷贝的区别
深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的
+ 浅拷贝就是拷贝指向对象的指针,意思就是说:拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间.
---
+ 深拷贝指拷贝对象的具体内容,其内容地址是自助分配的,拷贝结束之后,内存中的值是完全相同的,但是内存地址是不一样的,两个对象之间相互不影响,也互不干涉.

### flex基本属性
+ flex-direction: 决定主轴的方向 (row | row-reverse | column | column-reverse)
+ flex-wrap: 如果一条轴线排不下，如何换行(nowrap | wrap | wrap-reverse)
+ justify-content: 定义项目在主轴上的对齐方式(flex-start | flex-end | center | space-between | space-around)
+ align-items: 定义项目在交叉轴上如何对齐 (flex-start | flex-end | center | baseline | stretch

### 判断一个字符串中出现次数最多的字符
```js
  let str=’addddfffssdfsadfsdfsafjsd’;
  let json={}; 
    // 1.定义一个空对象来存放 对象属性的值
    // 2.遍历字符串
   for(let i=0;i<str.length;i++){
     // 3.判断创建对象(json)是否有当前字符属性
     // 如果没有就初始化属性值为1, 否则就 +1
     if(!json[str.charAt(i)]){
            json[str.charAt(i)]=1;
     }else{
         json[str.charAt(i)]++;
     }
   }
   let iMax=0;
   let icur='';
   console.log(json);//{a:3,d:8,f:7,s:6,j:1}
   // 4.遍历 json对象取最大值œ
   for(let val in json){
     if(json[val]>iMax){
        iMax=json[val];
           icur=val;
     }
   }
   console.log(`${icur}----${iMax}`)
```
### 全局作用域中，用 const 和 let 声明的变量不在 window 上，有什么好处? 那到底在哪里获取？
> 用var声明全局变量有几个坏处
1. 无法在编译时就报出变量为声明的错误, 只有运行才知道; 因为全局变量是window创造的, 而属性的添加可能是动态的
2. 顶层对象的属性是到处可以读写, 不利于模块化编程
3. window指浏览器的窗口对象, 顶层对象是一个有实体含义的对象, 也不合适
> 在哪获取

![](http://ww1.sinaimg.cn/large/006tNc79gy1g4wfrza2sdj30np0at0uc.jpg)
![](http://ww4.sinaimg.cn/large/006tNc79gy1g4wflazej1j30xq0diq59.jpg)
